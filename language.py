# simple "input" and "control" functions
#All generated Questions are generated by these functions, also all language handling happens here
import spacy
from spacy.matcher import Matcher
import nltk 
from nltk.metrics import edit_distance
import json


with open("trucks.json","r") as f:
    Brand_list = json.load(f)
nlp = spacy.load("en_core_web_sm")

def get_closest(wordlist,token):
    distance = 1000
    closest = None
    for j in wordlist:
        t_distance = edit_distance(j.lower(),token.text.lower())
        if t_distance < distance:
            closest = j
            distance = t_distance
    if closest is not None:
        return True, closest
    else:
        return False, ""


def match_list(user_input,Node,expected_input):
    text_spacy = nlp(user_input)
    text_matches = []
    for token in text_spacy:
        candidates = []
        for result in expected_input:
            if is_Noun(token) and (token.text.lower() in result.lower()):
                candidates.append(result)
            else:
                distance = edit_distance(result.lower(),token.text.lower())
                if distance < 2:
                    candidates.append(result)
        success,match = get_closest(candidates,token)
        if success:
            text_matches.append(match)
    unique_matches = []
    [unique_matches.append(x) for x in text_matches if x not in unique_matches]
    if len(unique_matches)==1:
        return stringify(unique_matches)
    return unique_matches

def is_Noun(token):
    return token.tag_ in ["NNP","NNS","NNPS","X"]

def phrase_checker(phrase,pattern_list):
    matcher = Matcher(nlp.vocab)
    for i in range(len(pattern_list)):
        matcher.add("Confirmation", None, pattern_list[i])
    doc = nlp(phrase)
    matches = matcher(doc)
    return matches

def confirmation(phrase,Node):
    #Function to check if user confirms last statement
    matches = phrase_checker(phrase,[[{"LOWER": "yes"}],[{"LOWER": "correct"}],[{"LOWER": "right"}],[{"LOWER": "true"}]])
    if len(matches) > 0 and not cancel(phrase,Node):
        return True
    else:
        return False
    
def cancel(phrase,Node):
    #Function to check if user confirms last statement
    matches = phrase_checker(phrase,[[{"LOWER": "back"}],[{"LOWER": "stop"}],[{"LOWER": "false"}],[{"LOWER": "no"}]])
    doc = nlp(phrase)
    if len(matches) > 0:
        return True
    for token in doc:
        if token.dep_ == "neg":
            return True
    else:
        return False

def stringify(user_input):
    if isinstance(user_input,str):
        return user_input
    elif isinstance(user_input,list):

        return ", ".join(user_input)
    else:
        try:
            return_string = str(user_input)
            return return_string
        except:
            return ""

def get_brands(user_input,Node,wordlist = Brand_list.keys()):
    return match_list(user_input,Node,Brand_list.keys())

def get_model_list(Node,dict):
    return dict[Node.AllAnswers["Brand"]]

def get_types(user_input,Node,model_dict = Brand_list):
    return match_list(user_input,Node,get_model_list(Node,model_dict))

def ask_reference(Text,Reference,Node):
    return_string = Text + stringify(Node.AllAnswers[Reference]) + "?\n"
    return return_string

def ask_number_brand(Node):
    return ask_reference("How many of your trucks are from ","Brand",Node)

def ask_number_type(Node):
    return ask_reference("How many of your trucks are of type ","Type",Node)

def ask_types(Node):
    return ask_reference("What types are your trucks from ","Brand",Node) + type_list(Node)

def type_list(Node,type_dict=Brand_list):
    return "Options: " + " ".join(type_dict[Node.AllAnswers["Brand"]]) + "\n"

def ask_engine_size(Node):
    return ask_reference("What size is the engine of the trucks from model ","Type",Node)

def ask_axles(Node):
    return ask_reference("How many axles have the trucks of type ","Type",Node)

def ask_weight(Node):
    return ask_reference("What is the weight of trucks of type ","Type",Node)

def ask_load(Node):
    return ask_reference("What is the maximal load of the trucks of type ", "Type",Node)

def get_Name(user_input,Node):
    input_doc = nlp(user_input)
    persons = []
    for ent in input_doc.ents:
        if ent.label_ == "PERSON":
            persons.append(ent.text)
    if len(persons)>0:
        return stringify(persons)
    tokens = []
    for token in input_doc:
        if is_Noun(token):
            tokens.append(token.text)
    if tokens != []:
        return stringify(tokens)
    return None

def get_Company(user_input,Node):
    input_doc = nlp(user_input)
    companies = []
    for ent in input_doc.ents:
        if ent.label_ in ["ORG","PRODUCT","PERSON"]:
            companies.append(ent.text)
    if len(companies)>0:
        return stringify(companies)
    tokens = []
    for token in input_doc:
        if is_Noun(token):
            tokens.append(token.text)
    if tokens != []:
        return stringify(tokens)
    return None

def get_nothing(user_input,Node):
    return user_input

def get_number(user_input,Node=None,format=None):
    input_doc = nlp(user_input)
    numbers = []
    for token in input_doc:
        if token.pos_ == "NUM":
            numbers.append(token.text)
        else:
            try:
                format(token.text)
                numbers.append(token.text)
            except ValueError:
                pass
    if len(numbers)>0:
        return numbers[0]
    else:
        return None

def get_int(user_input,Node):
    return get_number(user_input,Node,int)

def get_float(user_input,Node):
    return get_number(user_input,Node,float)

def get_amount(user_input,Node):
    return get_int(user_input,Node)